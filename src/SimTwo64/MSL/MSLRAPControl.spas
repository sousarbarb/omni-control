{ CONSTANTS / DEFINES }
const
  DOUBLEFORMAT = '%.5g';
  PRECISIONFORMAT = '%.12g';
  FREQDIVPOSCTRL = 4;  // Only executes the positioning controller after FREQDIVPOSCTRL * Tscript
  // Robot
  ROBOT_WH_D = 0.102;
  ROBOT_L    = 0.195;
  iROBOT  = 0;
  NUM_MOT = 3;
  iKICKER = 0;
  iMOT1  = 1;
  iMOT2  = 2;
  iMOT3  = 3;
  ENCRES = 12288;
  PI_KP  = 2.737441777222;
  PI_TAU = 0.208736119092;
  PI_LAG = 0.00;
  PI_DIVTAU = 1.5;
  PI_VDEAD = 1.0;
  PI_VOK   = 1.5;
  PD_KP_X  = 1.0;
  PD_KP_Y  = 1.0;
  PD_KP_TH = 1.0;
  PD_TAU_X  = 0.129073;
  PD_TAU_Y  = 0.128070;
  PD_TAU_TH = 0.099488;
  PD_TSETT = 0.8;
  // Trajectory (DO NOT CHANGE THIS PARAMETERS)
  NFUTURE = 10;
  GOAL_TOL_XY = 0.05; // meters
  GOAL_TOL_TH = 2.5;  // degrees
  XVEL = 0.75;



{ TYPES DEFINITION }
type
  TRobotPosData = (pdGT,pdODO);

  TPICtrl = record
    kc,ti,vdead,vok: double;
  end;

  TPDCtrl = record
    kc,td: double;
  end;

  TRobModel = record
    kp,tau: double;
  end;

  TChartType = (ctPosXY,ctPosT);



{ GLOBAL VARIABLES }
var
  chart_on, log_on, debug_on: boolean;
  Tscript, time_var: double;
  iFREQDIVPOSCTRL: integer;
  Log: TStringList;
  robpData: TRobotPosData;
  chart_type: TChartType;

  // Robot
  ctrlff_on: boolean;
  mot_param: TMotorPars;
  mot_fric:  TFrictionDef;
  mot_ctrl:  TPICtrl;
  vmot, wmot, wmot_r, wmot_e, wmot_eint: array [iMOT1..iMOT3] of double;
  robv, robv_r, robv_pd_r, robv_ff_r: array [1..3] of double; // v,vn,w
  rob_model : array [1..3] of TRobModel;  // v,vn,w
  rob_pdctrl: array [1..3] of TPDCtrl;    // v,vn,w
  robp_loc, robp_loc_r, robp_loc_e, robp_loc_eprev, robp_loc_ederiv: array [1..3] of double; // x,y,th
  robd       : array [1..3] of double; // delta_dv,delta_vn,delta_w
  robpodo    : array [1..3] of double; // xodo, yodo, thodo
  robpgt     : array [1..3] of double; // xgt , ygt , thgt
  robp,robp_r: array [1..3] of double; // x   , y   , th
  robp_r_1deriv,robp_r_2deriv: array [1..3] of double;         // x   , y   , th
  robp_loc_r_1deriv,robp_loc_r_2deriv: array [1..3] of double; // x   , y   , th
  // Trajectory
  trajectory_on: boolean;
  trajectory_file: TStringList;
  trajectory_numpoints: integer;
  trajectory: Matrix;
  i_global: integer;
  t_global, u_ref: double;
  matX_acc, matXinv_acc, matXtX_acc, matXtXinv_acc: Matrix;  // (to compute the acceleration)
  matX_vel, matXinv_vel, matXtX_vel, matXtXinv_vel: Matrix;  // (to compute the velocity)
  matBuffFutureX,matBuffFutureY,matBuffFutureTH: Matrix;
  matFutTrajApproxCoeffX       ,matFutTrajApproxCoeffY       ,matFutTrajApproxCoeffTH       : Matrix;
  matFutTrajApproxCoeffX_1deriv,matFutTrajApproxCoeffY_1deriv,matFutTrajApproxCoeffTH_1deriv: Matrix;
  matFutTrajApproxCoeffX_2deriv,matFutTrajApproxCoeffY_2deriv,matFutTrajApproxCoeffTH_2deriv: Matrix;



procedure ResetRobotInfo;
var
  i: integer;
begin
  SetRobotPos(iROBOT,0,0,0,0);
  for i:= 0 to 2 do begin
    vmot[i+iMOT1]      := 0;
    wmot[i+iMOT1]      := 0;
    wmot_r[i+iMOT1]    := 0;
    wmot_e[i+iMOT1]    := 0;
    wmot_eint[i+iMOT1] := 0;
    robv[i+1]      := 0;
    robv_r[i+1]    := 0;
    robp_loc[i+1]        := 0;
    robp_loc_r[i+1]      := 0;
    robp_loc_e[i+1]      := 0;
    robp_loc_eprev[i+1]  := 0;
    robp_loc_ederiv[i+1] := 0;
    robp[i+1]    := 0;
    robp_r[i+1]  := 0;
    robd[i+1]    := 0;
    robpodo[i+1] := 0;
    robp_r_1deriv[i+1]     := 0;
    robp_r_2deriv[i+1]     := 0;
    robp_loc_r_1deriv[i+1] := 0;
    robp_loc_r_2deriv[i+1] := 0;
  end;
end;

procedure UpdateRobotInfo;
var
  i: integer;
begin
  // - angular velocity
  for i := iMOT1 to iMOT3 do begin
    wmot[i] := 2*pi*GetAxisOdo(iROBOT,i)/(Tscript*ENCRES);
  end;
  // - robot velocity
  robv[1] := -( -wmot[iMOT1] + wmot[iMOT2]                 ) * Sqrt(3) * ROBOT_WH_D / 6;
  robv[2] := -( -wmot[iMOT1] - wmot[iMOT2] + 2*wmot[iMOT3] )           * ROBOT_WH_D / 6;
  robv[3] := -( -wmot[iMOT1] - wmot[iMOT2] -   wmot[iMOT3] )           * ROBOT_WH_D / (6 * ROBOT_L);
  // - robot displacement (local frame)
  for i:= 1 to 3 do begin
    robd[i] := robv[i] * Tscript;
  end;
  // - odometry
  if (robv[3] = 0) then begin
    robpodo[1] := robpodo[1] + robd[1]*cos(robpodo[3]) - robd[2]*sin(robpodo[3]);
    robpodo[2] := robpodo[2] + robd[1]*sin(robpodo[3]) + robd[2]*cos(robpodo[3]);
  end else begin
    robpodo[1] := robpodo[1] + (
                                 ( robd[1]*sin(robd[3])     + robd[2]*(cos(robd[3])-1) ) * cos( robpodo[3] + robd[3]/2 ) -
                                 ( robd[1]*(1-cos(robd[3])) + robd[2]*sin(robd[3])     ) * sin( robpodo[3] + robd[3]/2 )
                               ) / robd[3];
    robpodo[2] := robpodo[2] + (
                                 ( robd[1]*sin(robd[3])     + robd[2]*(cos(robd[3])-1) ) * sin( robpodo[3] + robd[3]/2 ) +
                                 ( robd[1]*(1-cos(robd[3])) + robd[2]*sin(robd[3])     ) * cos( robpodo[3] + robd[3]/2 )
                               ) / robd[3];
  end;
  robpodo[3] := NormalizeAngle(robpodo[3] + robd[3]);
  // - ground-truth
  robpgt[1] := GetRobotX(iROBOT);
  robpgt[2] := GetRobotY(iROBOT);
  robpgt[3] := GetRobotTheta(iROBOT);
  // - local frame
  case (robpData) of
    pdGT: begin
      for i:= 1 to 3 do begin
        robp[i] := robpgt[i];
      end;
    end;

    pdODO: begin
      for i:= 1 to 3 do begin
        robp[i] := robpodo[i];
      end;
    end;
  end;
  robp_loc[1] :=  robp[1]*cos(robp[3]) + robp[2]*sin(robp[3]);
  robp_loc[2] := -robp[1]*sin(robp[3]) + robp[2]*cos(robp[3]);
  robp_loc[3] :=  robp[3];
end;

procedure ShowRobotInfo;
var
  i: integer;
begin
  // - robot information:
  SetRCValue(3,2,format(DOUBLEFORMAT,[ robpgt[1]      ]));
  SetRCValue(4,2,format(DOUBLEFORMAT,[ robpgt[2]      ]));
  SetRCValue(5,2,format(DOUBLEFORMAT,[ Deg(robpgt[3]) ]));
  SetRCValue(3,4,format(DOUBLEFORMAT,[ GetRobotVx(iROBOT) ]));
  SetRCValue(4,4,format(DOUBLEFORMAT,[ GetRobotVy(iROBOT) ]));
  SetRCValue(5,4,format(DOUBLEFORMAT,[ GetRobotW(iROBOT)  ]));
  SetRCValue(3,6,format(DOUBLEFORMAT,[  GetRobotVx(iROBOT)*cos(GetRobotTheta(iROBOT)) + GetRobotVy(iROBOT)*sin(GetRobotTheta(iROBOT)) ]));
  SetRCValue(4,6,format(DOUBLEFORMAT,[ -GetRobotVx(iROBOT)*sin(GetRobotTheta(iROBOT)) + GetRobotVy(iROBOT)*cos(GetRobotTheta(iROBOT)) ]));
  SetRCValue(5,6,format(DOUBLEFORMAT,[ GetRobotW(iROBOT)                                                                              ]));
  // - motors information:
  for i:=0 to NUM_MOT-1 do begin
    SetRCValue(7 , 2+i ,format('%d',[ GetAxisOdo(iROBOT, i+iMOT1 ) ]));
    SetRCValue(8 , 2+i ,format(DOUBLEFORMAT,[ 2*pi*GetAxisOdo(iROBOT, i+iMOT1 )/(Tscript*ENCRES) ]));
    SetRCValue(9 , 2+i ,format(DOUBLEFORMAT,[ GetAxisSpeed(iROBOT, i+iMOT1 ) ]));
    SetRCValue(10, 2+i ,format(DOUBLEFORMAT,[ (GetAxisU(iROBOT, i+iMOT1 ) - mot_param.ri*GetAxisI(iROBOT, i+iMOT1 )) / (mot_param.ki) ]));
    SetRCValue(11, 2+i ,format(DOUBLEFORMAT,[ GetAxisU(iROBOT, i+iMOT1 ) ]));
    SetRCValue(12, 2+i ,format(DOUBLEFORMAT,[ GetAxisI(iROBOT, i+iMOT1 ) ]));
  end;
  // - robot odometry information
  for i:=0 to 2 do begin
    if (i = 2) then begin
      SetRCValue(23+i,2,format(DOUBLEFORMAT,[ Deg(robpodo[i+1]) ]));
      SetRCValue(23+i,4,format(DOUBLEFORMAT,[ Deg(robd[i+1])    ]));
    end else begin
      SetRCValue(23+i,2,format(DOUBLEFORMAT,[ robpodo[i+1] ]));
      SetRCValue(23+i,4,format(DOUBLEFORMAT,[ robd[i+1]    ]));
    end;
    SetRCValue(23+i,6,format(DOUBLEFORMAT,[ robv[i+1] ]));
  end;
end;



procedure MotorVoltageHammerstein(var motor_volt: double);
begin
  if (motor_volt > mot_ctrl.vdead) then begin
    motor_volt := (motor_volt - mot_ctrl.vdead) + mot_ctrl.vok;
  end else if (motor_volt > -mot_ctrl.vdead) then begin
    if (mot_ctrl.vdead <> 0) then begin
      motor_volt := motor_volt * mot_ctrl.vok / mot_ctrl.vdead;
    end else begin
      motor_volt := 0;
    end;
  end else begin
    motor_volt := (motor_volt + mot_ctrl.vdead) - mot_ctrl.vok;
  end;
end;

procedure PIMotorsControllers;
var
  i: integer;
  tmp_eint: double;
begin
  // PI controllers
  for i := iMOT1 to iMOT3 do begin
    // Errors (proportional and integral)
    wmot_e[i] := wmot_r[i] - wmot[i];
    tmp_eint  := wmot_eint[i] + wmot_e[i] * Tscript;

    // Remove integration for zero reference
    if (wmot_r[i] = 0) then begin
      tmp_eint := 0;
    end;

    // Voltage (without saturation)
    if (mot_ctrl.ti = 0) then begin
      vmot[i] := mot_ctrl.kc * wmot_e[i];
    end else begin
      vmot[i] := mot_ctrl.kc * ( wmot_e[i] + tmp_eint / mot_ctrl.ti );
    end;

    // Increase gain in the deadzone
    MotorVoltageHammerstein(vmot[i]);

    // Voltage (with saturation): to prevent the windup effect
    if (((vmot[i] > mot_param.vmax) AND (tmp_eint > 0)) OR ((vmot[i] < -mot_param.vmax) AND (tmp_eint < 0))) then begin
      vmot[i] := vmot[i] + mot_ctrl.kc * (wmot_eint[i] - tmp_eint) / mot_ctrl.ti;
    end else begin
      wmot_eint[i] := tmp_eint;
    end;

    // Saturate the output
    if (vmot[i] > mot_param.vmax) then begin
      vmot[i] := mot_param.vmax;
    end else if (vmot[i] < -mot_param.vmax) then begin
      vmot[i] := -mot_param.vmax;
    end;

    SetAxisVoltageRef(iROBOT,i,vmot[i]);
  end;
end;

procedure PDRobotPosControllers;
var
  i: integer;
begin
  for i:=1 to 3 do begin
    // PD controllers
    // - errors (proportional and derivative)
    if (i <> 3) then begin
      robp_loc_eprev[i]  := robp_loc_e[i];
      robp_loc_e[i]      := robp_loc_r[i] - robp_loc[i];
      robp_loc_ederiv[i] := (robp_loc_e[i] - robp_loc_eprev[i])/(4*Tscript);
    end else begin
      robp_loc_eprev[i]  := robp_loc_e[i];
      robp_loc_e[i]      := NormalizeAngle( robp_loc_r[i] - robp_loc[i]       );
      robp_loc_ederiv[i] := NormalizeAngle( robp_loc_e[i] - robp_loc_eprev[i] )/(4*Tscript);
    end;

    // - robot velocity
    robv_pd_r[i] := rob_pdctrl[i].kc * ( robp_loc_e[i] + rob_pdctrl[i].td * robp_loc_ederiv[i] );
  end;
end;

procedure FFRobotPosControllers;
var
  i: integer;
begin
  for i:=1 to 3 do begin
    // FF controllers
    robv_ff_r[i] := robp_loc_r_2deriv[i] * rob_model[i].tau / rob_model[i].kp + robp_loc_r_1deriv[i] / rob_model[i].kp;
  end;
end;

procedure RobotPosControllers;
var
  i: integer;
  scale,max_w: double;
begin
  // Position control
  // - global > local coordinate frame
  robp_loc_r[1] :=  robp_r[1]*cos(robp[3]) + robp_r[2]*sin(robp[3]);
  robp_loc_r[2] := -robp_r[1]*sin(robp[3]) + robp_r[2]*cos(robp[3]);
  robp_loc_r[3] :=  robp_r[3];
  robp_loc_r_1deriv[1] :=  robp_r_1deriv[1]*cos(robp[3]) + robp_r_1deriv[2]*sin(robp[3]);
  robp_loc_r_1deriv[2] := -robp_r_1deriv[1]*sin(robp[3]) + robp_r_1deriv[2]*cos(robp[3]);
  robp_loc_r_1deriv[3] :=  robp_r_1deriv[3];
  robp_loc_r_2deriv[1] :=  robp_r_2deriv[1]*cos(robp[3]) + robp_r_2deriv[2]*sin(robp[3]);
  robp_loc_r_2deriv[2] := -robp_r_2deriv[1]*sin(robp[3]) + robp_r_2deriv[2]*cos(robp[3]);
  robp_loc_r_2deriv[3] :=  robp_r_2deriv[3];
  // - proportional-derivative controllers
  PDRobotPosControllers;
  // - feedforward controllers
  if (ctrlff_on) then begin
    FFRobotPosControllers;
  end else begin
    for i:=1 to 3 do begin
      robv_ff_r[i] := 0;
    end;
  end;

  // Velocity of the robot
  for i:=1 to 3 do begin
    robv_r[i] := robv_pd_r[i] + robv_ff_r[i];
  end;

  // Inverse Kinematics
  wmot_r[iMOT1] := -( -Sqrt(3)*robv_r[1]/2 - robv_r[2]/2 - ROBOT_L*robv_r[3] ) * 2 / ROBOT_WH_D;
  wmot_r[iMOT2] := -(  Sqrt(3)*robv_r[1]/2 - robv_r[2]/2 - ROBOT_L*robv_r[3] ) * 2 / ROBOT_WH_D;
  wmot_r[iMOT3] := -(  0                   + robv_r[2]   - ROBOT_L*robv_r[3] ) * 2 / ROBOT_WH_D;
end;



procedure ConfigureCtrlModeRobotPosition;
var
  i: integer;
begin
  ResetRobotInfo;

  iFREQDIVPOSCTRL := 0;
  trajectory_on := false;
  SetRCValue( 6, 9,'Filename:');
  SetRCValue( 6,10,'#points:');
  SetRCValue( 6,12,'state:');
  SetRCValue( 7, 8,'[LoadTraj]');
  SetRCValue( 9, 9,'x (m):');
  SetRCValue( 9,10,'y (m):');
  SetRCValue( 9,11,'th (deg):');
  SetRCValue(10, 8,'Goal:');
  SetRCValue(11, 8,'Xref:');
  SetRCValue(12, 8,'FUTURE:');
  SetRCValue(12, 9,'x (m):');
  SetRCValue(12,10,'y (m):');
  SetRCValue(12,11,'th (deg):');
  for i:=0 to NFUTURE-1 do begin
    SetRCValue(13+i,8, format('(%d):',[ i ]) );
  end;

  SetRCValue(8,8,'[FFOnOff]');
  SetRCValue(8,10,'[GT/ODO]');

  ChartSeriesSetCount(0,NUM_MOT*2);
  ChartSeriesSetColor(0,0,clRed);
  ChartSeriesSetColor(0,1,clRed);
  ChartSeriesSetColor(0,2,clGreen);
  ChartSeriesSetColor(0,3,clGreen);
  ChartSeriesSetColor(0,4,clBlue);
  ChartSeriesSetColor(0,5,clBlue);
end;

procedure InitializeBuffers(i0: integer);
var
  i, last_i: integer;
  p0x,p0y,p0th,v0x,v0y,v0th: double;
  matApproxCoeffTempX,matApproxCoeffTempY,matApproxCoeffTempTH,matBuffFutureTempX,matBuffFutureTempY,matBuffFutureTempTH: Matrix;
begin
  // Initialization    
  matBuffFutureX  := Mzeros(NFUTURE,1);
  matBuffFutureY  := Mzeros(NFUTURE,1);
  matBuffFutureTH := Mzeros(NFUTURE,1);
  matFutTrajApproxCoeffX         := Mzeros(3,1);
  matFutTrajApproxCoeffY         := Mzeros(3,1);
  matFutTrajApproxCoeffTH        := Mzeros(3,1);
  matFutTrajApproxCoeffX_1deriv  := Mzeros(3,1);
  matFutTrajApproxCoeffY_1deriv  := Mzeros(3,1);
  matFutTrajApproxCoeffTH_1deriv := Mzeros(3,1);
  matFutTrajApproxCoeffX_2deriv  := Mzeros(3,1);
  matFutTrajApproxCoeffY_2deriv  := Mzeros(3,1);
  matFutTrajApproxCoeffTH_2deriv := Mzeros(3,1);

  // Initialize initial position and velocity
  // - Initial position (1st restriction):
  if (i0 < trajectory_numpoints) then begin
    p0x := Mgetv(trajectory,i0,0);
    p0y := Mgetv(trajectory,i0,1);
    p0th:= Mgetv(trajectory,i0,2);
  end else begin
    p0x := Mgetv(trajectory,trajectory_numpoints-1,0);
    p0y := Mgetv(trajectory,trajectory_numpoints-1,1);
    p0th:= Mgetv(trajectory,trajectory_numpoints-1,2);
  end;
  // - Initial velocity (1st restriction):
  if (i0+1 < trajectory_numpoints) then begin
    v0x :=                Mgetv(trajectory,i0+1,0) - Mgetv(trajectory,i0,0);
    v0y :=                Mgetv(trajectory,i0+1,1) - Mgetv(trajectory,i0,1);
    v0th:= NormalizeAngle(Mgetv(trajectory,i0+1,2) - Mgetv(trajectory,i0,2));
  end else begin
    v0x := 0;
    v0y := 0;
    v0th:= 0;
  end;
  // - Auxiliar variables:
  matBuffFutureTempX := Mzeros(NFUTURE,1);
  matBuffFutureTempY := Mzeros(NFUTURE,1);
  matBuffFutureTempTH:= Mzeros(NFUTURE,1);

  // Initialize the future/horizon buffer
  last_i := 0;
  for i:=0 to NFUTURE-1 do begin
    // Index outside the trajectory
    if (i+i0 >= trajectory_numpoints) then begin
      break;
    end;

    // Buffer
    Msetv(matBuffFutureX ,i,0, Mgetv(trajectory,i+i0,0) );
    Msetv(matBuffFutureY ,i,0, Mgetv(trajectory,i+i0,1) );
    Msetv(matBuffFutureTH,i,0, Mgetv(trajectory,i+i0,2) );
    // Auxiliar matrices
    Msetv(matBuffFutureTempX ,i,0,                Mgetv(trajectory,i+i0,0) - p0x  - v0x  * i );
    Msetv(matBuffFutureTempY ,i,0,                Mgetv(trajectory,i+i0,1) - p0y  - v0y  * i );
    Msetv(matBuffFutureTempTH,i,0, NormalizeAngle(Mgetv(trajectory,i+i0,2) - p0th - v0th * i) );

    last_i := last_i + 1;
  end;
  // - retain final pose of the trajectory
  for i:=last_i to NFUTURE-1 do begin
    // Buffer
    Msetv(matBuffFutureX ,i,0, Mgetv(trajectory,trajectory_numpoints-1,0) );
    Msetv(matBuffFutureY ,i,0, Mgetv(trajectory,trajectory_numpoints-1,1) );
    Msetv(matBuffFutureTH,i,0, Mgetv(trajectory,trajectory_numpoints-1,2) );
    // Auxiliar matrices
    Msetv(matBuffFutureTempX ,i,0,                Mgetv(trajectory,trajectory_numpoints-1,0) - p0x  - v0x  * i );
    Msetv(matBuffFutureTempY ,i,0,                Mgetv(trajectory,trajectory_numpoints-1,1) - p0y  - v0y  * i );
    Msetv(matBuffFutureTempTH,i,0, NormalizeAngle(Mgetv(trajectory,trajectory_numpoints-1,2) - p0th - v0th * i) );
  end;
  // - Unwrap the orientation
  for i:=1 to NFUTURE-1 do begin
    Msetv(matBuffFutureTH    ,i,0, Mgetv(matBuffFutureTH    ,i-1,0) + NormalizeAngle(Mgetv(matBuffFutureTH    ,i,0) - Mgetv(matBuffFutureTH    ,i-1,0)) );
    Msetv(matBuffFutureTempTH,i,0, Mgetv(matBuffFutureTempTH,i-1,0) + NormalizeAngle(Mgetv(matBuffFutureTempTH,i,0) - Mgetv(matBuffFutureTempTH,i-1,0)) );
  end;

  // Estimate approximated trajectory matTrajApproxCoeff
  // - TH:
  //   - Position (not required):
  matApproxCoeffTempTH := Mmult(matXinv_acc , matBuffFutureTempTH );
  Msetv(matFutTrajApproxCoeffTH,0,0, p0th );
  Msetv(matFutTrajApproxCoeffTH,1,0, v0th );
  Msetv(matFutTrajApproxCoeffTH,2,0, (0.5) * Mgetv(matApproxCoeffTempTH,0,0) );
  //   - Acceleration (2nd-order approximation with restrictions):
  Msetv(matFutTrajApproxCoeffTH_2deriv,0,0, Mgetv(matApproxCoeffTempTH,0,0)  );
  //   - Velocity (1st-order approximation):
  matApproxCoeffTempTH := Mmult( matXinv_vel , matBuffFutureTH  );
  Msetv(matFutTrajApproxCoeffTH_1deriv,0,0, Mgetv(matApproxCoeffTempTH,1,0)  );
  // - X,Y:
  //   - Position (not required):
  matApproxCoeffTempX := Mmult( matXinv_acc , matBuffFutureTempX  );  // a2_x, a3_x, ..., aNpoly_x
  matApproxCoeffTempY := Mmult( matXinv_acc , matBuffFutureTempY  );  // a2_y, a3_y, ..., aNpoly_y
  Msetv(matFutTrajApproxCoeffX,0,0, p0x );
  Msetv(matFutTrajApproxCoeffX,1,0, v0x );
  Msetv(matFutTrajApproxCoeffX,2,0, (0.5) * Mgetv(matApproxCoeffTempX,0,0) );
  Msetv(matFutTrajApproxCoeffY,0,0, p0y );
  Msetv(matFutTrajApproxCoeffY,1,0, v0y );
  Msetv(matFutTrajApproxCoeffY,2,0, (0.5) * Mgetv(matApproxCoeffTempY,0,0) );
  //   - Acceleration (2nd-order approximation with restrictions):
  Msetv(matFutTrajApproxCoeffX_2deriv,0,0, Mgetv(matApproxCoeffTempX,0,0)  );
  Msetv(matFutTrajApproxCoeffY_2deriv,0,0, Mgetv(matApproxCoeffTempY,0,0)  );
  //   - Velocity (1st-order approximation):
  matApproxCoeffTempX := Mmult( matXinv_vel , matBuffFutureX  );
  matApproxCoeffTempY := Mmult( matXinv_vel , matBuffFutureY  );
  Msetv(matFutTrajApproxCoeffX_1deriv,0,0, Mgetv(matApproxCoeffTempX,1,0)  );
  Msetv(matFutTrajApproxCoeffY_1deriv,0,0, Mgetv(matApproxCoeffTempY,1,0)  );

  // Debug
  if (debug_on) then begin
    MatrixToRange(13, 9,matBuffFutureX);
    MatrixToRange(13,10,matBuffFutureY);
    MatrixToRange(13,11,matBuffFutureTH);
  end;
end;

procedure ReadTrajectoryFile;
var
  i,j: integer;
  line_file: TStringList;
begin
  trajectory_on := true;

  // If the stringlist has memory allocated, free the object
  if (trajectory_file <> nil) then begin
    trajectory_file.Clear;
    trajectory_file.Free;
  end;

  // Load file
  trajectory_file := TStringList.Create;
  trajectory_file.LoadFromFile('trajectories/' + GetRCText(7,9) + '.txt');

  // Initialization
  trajectory_numpoints := trajectory_file.Count;
  trajectory := Mzeros(trajectory_numpoints,3);
  SetRCValue(7,10, format('%d',[ trajectory_numpoints ]) );

  // Process trajectory (trajectory + 1st future points)
  for i:=0 to (trajectory_numpoints-1) do begin
    // Print the entire line (see Output in the Editor window)
    //WriteLn(trajectory_file.Strings[i]);

    // Process each cell of the CSV format
    if (line_file <> nil) then begin
      line_file.Clear;
      line_file.Free;
    end;
    line_file := TStringList.Create;
    line_file.Delimiter     := ',';
    line_file.DelimitedText := trajectory_file.Strings[i];
    
    // Associate point of the trajectory
    Msetv(trajectory,i,0, StrToFloat( line_file.Strings[0] ) );  // X
    Msetv(trajectory,i,1, StrToFloat( line_file.Strings[1] ) );  // Y
    Msetv(trajectory,i,2, StrToFloat( line_file.Strings[2] ) );  // Theta
  end;
  // Free allocated space, if necessary
  if (line_file <> nil) then begin
    line_file.Clear;
    line_file.Free;
  end;

  // Set the first future
  i_global := 0;
  t_global := 0;
  time_var := 0;
  InitializeBuffers(i_global);
end;

function IsGoalReached(xf, yf, thf: double): boolean;
begin
  if ((Dist(xf - robp_r[1], yf - robp_r[2]) < GOAL_TOL_XY) AND
      (Abs(NormalizeAngle(thf - robp_r[3])) < Deg(GOAL_TOL_TH))) then begin
    result := true;
    SetRCValue(10,12,'OK!');
  end else begin
    result := false;
    SetRCValue(10,12,'Not reached');
  end;
  SetRCValue(10, 9,format(DOUBLEFORMAT,[ xf ]));
  SetRCValue(10,10,format(DOUBLEFORMAT,[ yf ]));
  SetRCValue(10,11,format(DOUBLEFORMAT,[ Deg(thf) ]));
end;

function Ceil(x: double): LongInt;
begin
  if (x - Round(x) > 0) then begin
    result := Round(x) + 1;
  end else begin
    result := Round(x);
  end;
end;

function Floor(x: double): LongInt;
begin
  if (x - Round(x) > 0) then begin
    result := Round(x);
  end else begin
    result := Round(x) - 1;
  end;
end;

procedure SetPositionControllerFFReferences;
var
  u_0, u_f: integer;
begin
  // Global time
  t_global := t_global + (Tscript*FREQDIVPOSCTRL);
  // Reference indexes
  u_ref := t_global * XVEL / (Tscript*FREQDIVPOSCTRL) - i_global * 1.0;
  while (u_ref >= 1) do begin
    i_global := i_global + 1;
    u_ref := t_global * XVEL / (Tscript*FREQDIVPOSCTRL) - i_global * 1.0;
  end;
  InitializeBuffers(i_global);
  
  // Interpolation
  u_0 := Floor(u_ref);
  u_f := u_0 + 1;
  if (u_0 < 0) then begin
    u_0 := 0;
    u_f := 1;
  end;

  // Set reference
  // - position (interpolation):
  robp_r[1] := Mgetv(matBuffFutureX ,u_0,0) +
              (Mgetv(matBuffFutureX ,u_f,0) - Mgetv(matBuffFutureX ,u_0,0)) * (u_ref - u_0 * 1.0);
  robp_r[2] := Mgetv(matBuffFutureY ,u_0,0) +
              (Mgetv(matBuffFutureY ,u_f,0) - Mgetv(matBuffFutureY ,u_0,0)) * (u_ref - u_0 * 1.0);
  robp_r[3] := Mgetv(matBuffFutureTH,u_0,0) +
              (Mgetv(matBuffFutureTH,u_f,0) - Mgetv(matBuffFutureTH,u_0,0)) * (u_ref - u_0 * 1.0);
  // - first derivative:
  robp_r_1deriv[1] := Mgetv(matFutTrajApproxCoeffX_1deriv ,0,0);
  robp_r_1deriv[2] := Mgetv(matFutTrajApproxCoeffY_1deriv ,0,0);
  robp_r_1deriv[3] := Mgetv(matFutTrajApproxCoeffTH_1deriv,0,0);
  // - second derivative:
  robp_r_2deriv[1] := Mgetv(matFutTrajApproxCoeffX_2deriv ,0,0);
  robp_r_2deriv[2] := Mgetv(matFutTrajApproxCoeffY_2deriv ,0,0);
  robp_r_2deriv[3] := Mgetv(matFutTrajApproxCoeffTH_2deriv,0,0);
  // u -> t
  robp_r_1deriv[1] := robp_r_1deriv[1] * XVEL / (Tscript*FREQDIVPOSCTRL);
  robp_r_1deriv[2] := robp_r_1deriv[2] * XVEL / (Tscript*FREQDIVPOSCTRL);
  robp_r_1deriv[3] := robp_r_1deriv[3] * XVEL / (Tscript*FREQDIVPOSCTRL);
  robp_r_2deriv[1] := robp_r_2deriv[1] * XVEL / (Tscript*FREQDIVPOSCTRL);
  robp_r_2deriv[2] := robp_r_2deriv[2] * XVEL / (Tscript*FREQDIVPOSCTRL);
  robp_r_2deriv[3] := robp_r_2deriv[3] * XVEL / (Tscript*FREQDIVPOSCTRL);

  // Debug
  if (debug_on) then begin
    SetRCValue(11, 9,format(DOUBLEFORMAT,[ robp_r[1]      ]));
    SetRCValue(11,10,format(DOUBLEFORMAT,[ robp_r[2]      ]));
    SetRCValue(11,11,format(DOUBLEFORMAT,[ Deg(robp_r[3]) ]));
  end;
end;

procedure CtrlModeRobotPosition;
var
  i,j: integer;
begin
  // Setup: Chart
  // - clear
  if (RCButtonPressed(4,12)) then begin
    time_var := 0;
    for i := 0 to 5 do begin
      ChartSeriesClear(0,i);
    end;
  end;
  // - select type chart
  if (RCButtonPressed(4,10)) then begin
    if (chart_type = ctPosXY) then begin
      chart_type := ctPosT;
      SetRCValue(4,11,'PosTime');
    end else begin
      chart_type := ctPosXY;
      SetRCValue(4,11,'PosXY');
    end;

    time_var := 0;
    ChartSeriesSetCount(0,NUM_MOT*2);
    ChartSeriesSetColor(0,0,clRed);
    ChartSeriesSetColor(0,1,clRed);
    ChartSeriesSetColor(0,2,clGreen);
    ChartSeriesSetColor(0,3,clGreen);
    ChartSeriesSetColor(0,4,clBlue);
    ChartSeriesSetColor(0,5,clBlue);
    for i := 0 to 5 do begin
      ChartSeriesClear(0,i);
    end;
  end;
  // - position data mode (ground-truth vs odometry)
  if (RCButtonPressed(8,10)) then begin
    if (robpData = pdGT) then begin
      robpData := pdODO;
      SetRCValue(8,11,'odometry');
    end else begin
      robpData := pdGT;
      SetRCValue(8,11,'sim2');
    end;
  end;
  // - feedforward controllers ON/OFF
  if (RCButtonPressed(8,8)) then begin
    if (ctrlff_on) then begin
      ctrlff_on := false;
      SetRCValue(8,9,'Off');
    end else begin
      ctrlff_on := true;
      SetRCValue(8,9,'On');
    end;
  end;
  // - load trajectory
  if (RCButtonPressed(7,8)) then begin
    ResetRobotInfo;
    ConfigureCtrlModeRobotPosition;
    ReadTrajectoryFile;

    time_var := 0;
    ChartSeriesSetCount(0,NUM_MOT*2);
    ChartSeriesSetColor(0,0,clRed);
    ChartSeriesSetColor(0,1,clRed);
    ChartSeriesSetColor(0,2,clGreen);
    ChartSeriesSetColor(0,3,clGreen);
    ChartSeriesSetColor(0,4,clBlue);
    ChartSeriesSetColor(0,5,clBlue);
    for i := 0 to 5 do begin
      ChartSeriesClear(0,i);
    end;
  end;



  // Position control of the omnidirectional robot
  // - update index to run position control at 40ms
  iFREQDIVPOSCTRL := iFREQDIVPOSCTRL + 1;
  // - position controllers
  if ( iFREQDIVPOSCTRL >= FREQDIVPOSCTRL) then begin

    // - check goal
    if (trajectory_on) then begin
      if ((IsGoalReached(Mgetv(trajectory,trajectory_numpoints-1,0),
                         Mgetv(trajectory,trajectory_numpoints-1,1),
                         Mgetv(trajectory,trajectory_numpoints-1,2))) AND
           (i_global >= trajectory_numpoints-1)) then begin
        trajectory_on := false;
      end;
    end;
    // - set position references
    if (trajectory_on) then begin
      SetPositionControllerFFReferences;
      SetRCValue(7,12,'GOOO!!!');
    end else begin
      SetRCValue(7,12,'END...');
    end;
    // - position control
    RobotPosControllers;

  end;
  // - motors PI controllers
  PIMotorsControllers;
  // - reset index
  if ( iFREQDIVPOSCTRL >= FREQDIVPOSCTRL) then begin
    iFREQDIVPOSCTRL := 0;
  end;



  // Chart
  if (chart_on) then begin
    case (chart_type) of
      ctPosXY: begin
        ChartSeriesAddXY(0,0,robp_r[1],robp_r[2]);
        ChartSeriesAddXY(0,4,robp[1]  ,robp[2]  );
      end;

      ctPosT: begin
        j := 0;
        for i := 1 to 3 do begin
          ChartSeriesAddXY(0,j  ,time_var,robp_r[i]);
          ChartSeriesAddXY(0,j+1,time_var,robp[i]);
          j := j + 2;
        end;
      end;
    end;
  end;
end;



procedure IMCmodelPIctrl(kp,tau,lag,divtau: double; out kcout,tiout: double);
var
  taucl: double;
begin
  if ((divtau <> 0) AND (tau <> 0) AND (kp <> 0)) then begin
    taucl := tau/divtau;
    kcout := (tau/(taucl+lag)) / kp;
    tiout := tau;
  end else begin
    kcout := 0;
    tiout := 0;
  end;
end;

procedure BesselPrototypePDctrl(robMmodel: Matrix; Tsettling: double; besselPoles: Matrix);
var
  i: integer;
  a0,a1,re,im: double;
begin
  // Compute the coefficients of the characteristic polynomial (roots' polynomial in closed loop)
  re := Mgetv(besselPoles,0,0);
  im := Mgetv(besselPoles,0,1);
  a0 := ( Sqr(re) + Sqr(im) ) / Sqr(Tsettling);
  a1 := -2*re/Tsettling;
  SetRCValue(33,6,Format(PRECISIONFORMAT,[a0]));
  SetRCValue(34,6,Format(PRECISIONFORMAT,[a1]));

  // Compute the gains for the PD controller
  for i:=1 to 3 do begin
    rob_model[i].kp  := Mgetv(robMmodel,0,i-1);
    rob_model[i].tau := Mgetv(robMmodel,1,i-1);
    rob_pdctrl[i].kc := a0*rob_model[i].tau/rob_model[i].kp;
    rob_pdctrl[i].td := (a1*rob_model[i].tau - 1)/(rob_model[i].kp*rob_pdctrl[i].kc);
    // Debug
    SetRCValue(33,2+i-1,Format(PRECISIONFORMAT,[rob_pdctrl[i].kc]));
    SetRCValue(34,2+i-1,Format(PRECISIONFORMAT,[rob_pdctrl[i].td]));
  end;
end;



procedure ConfigureLog;
var
  string_log: String;
begin
  log_on := true;
  if (Log <> nil) then begin
    Log.Clear;
    Log.Free;
  end;
  SetRCValue(2,12,'');
  Log := TStringList.Create;
  // - metadata
  Log.Add('METADATA,');
  Log.Add(',Tscript (s),wmax (bool),wmax (rad/s),L (m),wh D (m),ctrlMode,robpCtrlMode,FREQDIVPOSCTRL,feed-forward (bool),');
  string_log := '';
  string_log := string_log + Format('General,%g,',[Tscript*1.0]);
  string_log := string_log + 'OFF,';
  string_log := string_log + Format('%g,%g,%g,',[0.0,ROBOT_L*1.0,ROBOT_WH_D*1.0]);
  string_log := string_log + 'cmRobP,';
  string_log := string_log + 'pcmTXT,';
  string_log := string_log + Format('%d,',[FREQDIVPOSCTRL]);
  if (ctrlff_on) then begin
    string_log := string_log + 'ON,';
  end else begin
    string_log := string_log + 'OFF,';
  end;
  Log.Add(string_log);
  Log.Add(',ri (ohm),ki (Nm/A),vmax (V),imax (A),n:1 (gear),bv (dynamic),fc (static),kc (V / rad/s),ti (s),');
  Log.Add(Format('Motor,%g,%g,%g,%g,%g,%g,%g,%g,%g,',[mot_param.ri,mot_param.ki,mot_param.vmax,mot_param.imax,mot_param.gearRatio,mot_fric.bv,mot_fric.fc,mot_ctrl.kc,mot_ctrl.ti]));
  Log.Add('Robot,(v):,(vn):,(w):,');
  Log.Add(Format('kp,%g,%g,%g,',[rob_model[1].kp,rob_model[2].kp,rob_model[3].kp]));
  Log.Add(Format('tau (s),%g,%g,%g,',[rob_model[1].tau,rob_model[2].tau,rob_model[3].tau]));
  Log.Add(Format('kc,%g,%g,%g,',[rob_pdctrl[1].kc,rob_pdctrl[2].kc,rob_pdctrl[3].kc]));
  Log.Add(Format('td (s),%g,%g,%g,',[rob_pdctrl[1].td,rob_pdctrl[2].td,rob_pdctrl[3].td]));
  Log.Add(',Filename,Nfuture,Npoly,Nudiv,');
  Log.Add(Format('pcmTxt,%s,%d,%d,%d,',[GetRCText(17,9),NFUTURE,2,0]));
  // - information header
  Log.Add('DATA,');
  string_log := '';
  string_log := string_log + 'time (s),time w/ T*4 (s),traj (bool),';
  string_log := string_log + 'v_m1 (V),v_m2 (V),v_m3 (V),';
  string_log := string_log + 'odo_m1 (tcks/cyc),odo_m2 (tcks/cyc),odo_m3 (tcks/cyc),';
  string_log := string_log + 'w_m1 (rad/s),w_m2 (rad/s),w_m3 (rad/s),';
  string_log := string_log + 'w_r_m1 (rad/s),w_r_m2 (rad/s),w_r_m3 (rad/s),';
  string_log := string_log + 'w_e_m1 (rad/s),w_e_m2 (rad/s),w_e_m3 (rad/s),';
  string_log := string_log + 'w_eint_m1 (rad/s),w_eint_m2 (rad/s),w_eint_m3 (rad/s),';
  string_log := string_log + 'v_rob (m/s),vn_rob (m/s),w_rob (rad/s),';
  string_log := string_log + 'v_r_rob (m/s),vn_r_rob (m/s),w_r_rob (rad/s),';
  string_log := string_log + 'v_pd_r_rob (m/s),vn_pd_r_rob (m/s),w_pd_r_rob (rad/s),';
  string_log := string_log + 'v_ff_r_rob (m/s),vn_ff_r_rob (m/s),w_ff_r_rob (rad/s),';
  string_log := string_log + 'px_loc (m),py_loc (m),pth_loc (rad),';
  string_log := string_log + 'px_r_loc (m),py_r_loc (m),pth_r_loc (rad),';
  string_log := string_log + 'px_r_1deriv_loc,py_r_1deriv_loc,pth_r_1deriv_loc,';
  string_log := string_log + 'px_r_2deriv_loc,py_r_2deriv_loc,pth_r_2deriv_loc,';
  string_log := string_log + 'px_e_loc (m),py_e_loc (m),pth_e_loc (rad),';
  string_log := string_log + 'px_e_1deriv_loc,py_e_1deriv_loc,pth_e_1deriv_loc,';
  string_log := string_log + 'px_gt (m),py_gt (m),pth_gt (rad),';
  string_log := string_log + 'px_odo (m),py_odo (m),pth_odo (rad),';
  string_log := string_log + 'px (m),py (m),pth (rad),';
  string_log := string_log + 'px_r (m),py_r (m),pth_r (rad),';
  string_log := string_log + 'px_r_1deriv,py_r_1deriv,pth_r_1deriv,';
  string_log := string_log + 'px_r_2deriv,py_r_2deriv,pth_r_2deriv,';
  string_log := string_log + 'xvel,i_global,u_ref,';
  Log.Add(string_log);
end;

procedure UpdateLog;
var
  string_log: String;
begin
  //string_log := '';
  string_log := string_log + Format('%.12g,%.12g,',[ time_var , t_global ]);
  if (trajectory_on) then begin
    string_log := string_log + '1,';
  end else begin
    string_log := string_log + '0,';
  end;
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ vmot[iMOT1]                , vmot[iMOT2]                , vmot[iMOT3]                ]);
  string_log := string_log + Format('%d,%d,%d,'         ,[ GetAxisOdo(iROBOT, iMOT1 ) , GetAxisOdo(iROBOT, iMOT2 ) , GetAxisOdo(iROBOT, iMOT3 ) ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ wmot[iMOT1]                , wmot[iMOT2]                , wmot[iMOT3]                ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ wmot_r[iMOT1]              , wmot_r[iMOT2]              , wmot_r[iMOT3]              ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ wmot_e[iMOT1]              , wmot_e[iMOT2]              , wmot_e[iMOT3]              ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ wmot_eint[iMOT1]           , wmot_eint[iMOT2]           , wmot_eint[iMOT3]           ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robv[1]                    , robv[2]                    , robv[3]                    ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robv_r[1]                  , robv_r[2]                  , robv_r[3]                  ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robv_pd_r[1]               , robv_pd_r[2]               , robv_pd_r[3]               ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robv_ff_r[1]               , robv_ff_r[2]               , robv_ff_r[3]               ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_loc[1]                , robp_loc[2]                , robp_loc[3]                ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_loc_r[1]              , robp_loc_r[2]              , robp_loc_r[3]              ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_loc_r_1deriv[1]       , robp_loc_r_1deriv[2]       , robp_loc_r_1deriv[3]       ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_loc_r_2deriv[1]       , robp_loc_r_2deriv[2]       , robp_loc_r_2deriv[3]       ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_loc_e[1]              , robp_loc_e[2]              , robp_loc_e[3]              ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_loc_ederiv[1]         , robp_loc_ederiv[2]         , robp_loc_ederiv[3]         ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robpgt[1]                  , robpgt[2]                  , robpgt[3]                  ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robpodo[1]                 , robpodo[2]                 , robpodo[3]                 ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp[1]                    , robp[2]                    , robp[3]                    ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_r[1]                  , robp_r[2]                  , robp_r[3]                  ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_r_1deriv[1]           , robp_r_1deriv[2]           , robp_r_1deriv[3]           ]);
  string_log := string_log + Format('%.12g,%.12g,%.12g,',[ robp_r_2deriv[1]           , robp_r_2deriv[2]           , robp_r_2deriv[3]           ]);
  if (trajectory_on) then begin
    string_log := string_log + Format('%.12g,%d,%.12g,',[ 1 , i_global , u_ref ]);
  end;
  Log.Add(string_log);
end;



procedure InitializeMatricesX(n_future: integer);
var
  i,j,u: integer;
begin
  // Least-squares with restrictions: acceleration (in terms of p0 and v0)
  matX_acc      := Mzeros(n_future,1);   // Assuming u=0,1,2,3,...
  matXinv_acc   := Mzeros(1,n_future);
  matXtX_acc    := Mzeros(1,1);
  matXtXinv_acc := Mzeros(1,1);
  u := 0;
  for i:=0 to n_future-1 do begin
    Msetv(matX_acc,i,0, Power(u,2) / 2 );
    u := u + 1;
  end;
  matXtX_acc    := Mmult( Mtran(matX_acc) , matX_acc );
  matXtXinv_acc := Minv(matXtX_acc);
  matXinv_acc   := Mmult( matXtXinv_acc , Mtran(matX_acc) );

  // Least-squares without restrictions: velocity
  matX_vel      := Mzeros(n_future,2);     // Assuming u=0,1,2,3,...
  matXinv_vel   := Mzeros(2,n_future);
  matXtX_vel    := Mzeros(2,2);
  matXtXinv_vel := Mzeros(2,2);
  for j:=0 to 1 do begin
    u := 0;
    for i:=0 to n_future-1 do begin
      Msetv(matX_vel,i,j, Power(u,j) );
      u := u + 1;
    end;
  end;
  matXtX_vel    := Mmult( Mtran(matX_vel) , matX_vel );
  matXtXinv_vel := Minv(matXtX_vel);
  matXinv_vel   := Mmult( matXtXinv_vel , Mtran(matX_vel) );
end;



{ CONTROL }
procedure Control;
var
  i: integer;
begin
  Tscript  := ScriptPeriod;
  time_var := time_var + Tscript;

  // Initialization
  UpdateRobotInfo;

  // Setup
  // - debug
  if (RCButtonPressed(1,8)) then begin
    if (debug_on) then begin
      debug_on := false;
      SetRCValue(1,9,'Off');
    end else begin
      debug_on := true;
      SetRCValue(1,9,'On');
    end;
  end;
  // - log
  if (RCButtonPressed(2,8)) then begin
    if (log_on) then begin
      log_on := false;
      SetRCValue(2,9,'Off');
    end else begin
      log_on := true;
      SetRCValue(2,9,'On');
      ConfigureLog;
    end;
  end;
  // - chart
  if (RCButtonPressed(4,8)) then begin
    if (chart_on) then begin
      chart_on := false;
      SetRCValue(4,9,'Off');
    end else begin
      chart_on := true;
      SetRCValue(4,9,'On');
      for i := 0 to 5 do begin
        ChartSeriesClear(0,i);
      end;
    end;
    time_var := 0;
    ChartSeriesSetCount(0,NUM_MOT*2);
    ChartSeriesSetColor(0,0,clRed);
    ChartSeriesSetColor(0,1,clRed);
    ChartSeriesSetColor(0,2,clGreen);
    ChartSeriesSetColor(0,3,clGreen);
    ChartSeriesSetColor(0,4,clBlue);
    ChartSeriesSetColor(0,5,clBlue);
  end;
  // - reset
  if (RCButtonPressed(1,3)) then begin
    ResetRobotInfo;
    ConfigureCtrlModeRobotPosition;
  end;



  // Control
  CtrlModeRobotPosition;



  // Show robot information
  if (debug_on) then
    ShowRobotInfo;

  // Log 
  // - add data to TStringList
  if (log_on) then begin
    UpdateLog;
  end;
  // - save button was pressed by the user
  if ((RCButtonPressed(2,10)) AND (Log <> nil)) then begin
    SetRCValue(2,12,'Saved in log/' + GetRCText(2,11) + '.csv');
    Log.SaveToFile('log/omnictrl_' + GetRCText(2,11) + '.csv' );
  end;
end;



{ INITIALIZATION }
procedure Initialize;
begin
  mot_param := GetMotorPars(iROBOT,iMOT1);
  mot_fric  := GetFrictionDef(iROBOT,iMOT1);
  mot_ctrl.vdead := PI_VDEAD;
  mot_ctrl.vok   := PI_VOK;
  debug_on := true;
  SetRCValue(1,9,'On');
  log_on := false;
  SetRCValue(1,11,'Filename:');
  SetRCValue(2,9,'Off');
  chart_on := false;
  SetRCValue(4,9,'Off');

  // Initialization Trajectory Control Matrices
  InitializeMatricesX(NFUTURE);

  // Reset the kicker
  SetAxisSpring(iROBOT,iKICKER,10,0);

  // Reset motors controller
  SetMotorControllerState(iROBOT,iMOT1,false);
  SetMotorControllerState(iROBOT,iMOT2,false);
  SetMotorControllerState(iROBOT,iMOT3,false);

  // Initial mode
  // - ff mode
  ctrlff_on := true;
  SetRCValue(8,9,'On');

  // - data to be used as robot's pose
  robpData := pdGT;
  //robpData := pdODO;
  SetRCValue(8,11,'sim2');
  //SetRCValue(8,11,'odometry');
  
  // - graph mode
  chart_type := ctPosXY;
  SetRCValue(4,11,'PosXY');

  ConfigureCtrlModeRobotPosition;

  // Reset sheet 
  // - robot information (position, velocity)
  SetRCValue(1,1,'ROBOT');
  SetRCValue(1,2,'INFO');
  SetRCValue(2,1,'POSVEL');
  SetRCValue(3,1,'x(m):');
  SetRCValue(4,1,'y(m):');
  SetRCValue(5,1,'th(ยบ):');
  SetRCValue(2,2,'(pos):');
  SetRCValue(3,3,'vx(m/s):');
  SetRCValue(4,3,'vy(m/s):');
  SetRCValue(5,3,'w(rad/s):');
  SetRCValue(2,4,'(GobV):');
  SetRCValue(3,5,'v(m/s):');
  SetRCValue(4,5,'vn(m/s):');
  SetRCValue(5,5,'w(rad/s):');
  SetRCValue(2,6,'(RobV):');
  // - motors information (odo, velocity, inputs controls)
  SetRCValue(6 ,1,'MOTORS');
  SetRCValue(7 ,1,'odo:');
  SetRCValue(8 ,1,'w_m:');
  SetRCValue(9 ,1,'w_s2:');
  SetRCValue(10,1,'(v-ri)/k:');
  SetRCValue(11,1,'v:');
  SetRCValue(12,1,'i:');
  SetRCValue(6 ,2,'(1):');
  SetRCValue(6 ,3,'(2):');
  SetRCValue(6 ,4,'(3):');
  SetRCValue(7 ,5,'(tks/cyc)');
  SetRCValue(8 ,5,'(rad/s)');
  SetRCValue(9 ,5,'(rad/s)');
  SetRCValue(10,5,'(rad/s)');
  SetRCValue(11,5,'(V)');
  SetRCValue(12,5,'(A)');
  // - motors parameters (simulation, controller)
  SetRCValue(13,1,'ri(ohm):');
  SetRCValue(14,1,'ki(Nm/A):');
  SetRCValue(15,1,'vmax(V):');
  SetRCValue(16,1,'imax(A):');
  SetRCValue(13,3,'n(n:1):');
  SetRCValue(14,3,'bv:');
  SetRCValue(15,3,'fc:');
  SetRCValue(13,2,format(PRECISIONFORMAT,[mot_param.ri]));
  SetRCValue(14,2,format(PRECISIONFORMAT,[mot_param.ki]));
  SetRCValue(15,2,format(PRECISIONFORMAT,[mot_param.vmax]));
  SetRCValue(16,2,format(PRECISIONFORMAT,[mot_param.imax]));
  SetRCValue(13,4,format(PRECISIONFORMAT,[mot_param.gearRatio]));
  SetRCValue(14,4,format(PRECISIONFORMAT,[mot_fric.bv]));
  SetRCValue(15,4,format(PRECISIONFORMAT,[mot_fric.fc]));
  SetRCValue(17,1,'MOTPI');
  SetRCValue(18,1,'kp:');
  SetRCValue(19,1,'tau:');
  SetRCValue(20,1,'lag:');
  SetRCValue(21,1,'divtau:');
  SetRCValue(20,3,'vdead:');
  SetRCValue(21,3,'vok:');
  SetRCValue(18,2,format(PRECISIONFORMAT,[PI_KP ]));
  SetRCValue(19,2,format(PRECISIONFORMAT,[PI_TAU]));
  SetRCValue(20,2,format(PRECISIONFORMAT,[PI_LAG]));
  SetRCValue(21,2,format(PRECISIONFORMAT,[PI_DIVTAU]));
  SetRCValue(20,4,format(PRECISIONFORMAT,[mot_ctrl.vdead]));
  SetRCValue(21,4,format(PRECISIONFORMAT,[mot_ctrl.vok]));
  IMCmodelPIctrl( GetRCValue(18,2) , GetRCValue(19,2) , GetRCValue(20,2) , GetRCValue(21,2) , mot_ctrl.kc , mot_ctrl.ti );
  SetRCValue(18,3,'kc:');
  SetRCValue(19,3,'ti:');
  SetRCValue(18,4,format(PRECISIONFORMAT,[mot_ctrl.kc]));
  SetRCValue(19,4,format(PRECISIONFORMAT,[mot_ctrl.ti]));
  // - robot information (odometry)
  SetRCValue(22,1,'ROBODO');
  SetRCValue(22,2,'(pos):');
  SetRCValue(23,1,'x(m):');
  SetRCValue(24,1,'y(m):');
  SetRCValue(25,1,'th(ยบ):');
  SetRCValue(23,3,'dx(m):');
  SetRCValue(24,3,'dy(m):');
  SetRCValue(25,3,'dth(ยบ):');
  SetRCValue(22,4,'(dpos):');
  SetRCValue(23,5,'v(m/s):');
  SetRCValue(24,5,'vn(m/s):');
  SetRCValue(25,5,'w(rad/s):');
  SetRCValue(22,6,'(RobV):');
  // - pd controller
  SetRCValue(26,1,'PDCTRL');
  SetRCValue(26,2,'(v):');
  SetRCValue(26,3,'(vn):');
  SetRCValue(26,4,'(w):');
  SetRCValue(27,1,'kp:');
  SetRCValue(27,2,format(PRECISIONFORMAT,[PD_KP_X ]));
  SetRCValue(27,3,format(PRECISIONFORMAT,[PD_KP_Y ]));
  SetRCValue(27,4,format(PRECISIONFORMAT,[PD_KP_TH]));
  SetRCValue(28,2,format(PRECISIONFORMAT,[PD_TAU_X ]));
  SetRCValue(28,3,format(PRECISIONFORMAT,[PD_TAU_Y ]));
  SetRCValue(28,4,format(PRECISIONFORMAT,[PD_TAU_TH]));
  SetRCValue(30,2,format(PRECISIONFORMAT,[PD_TSETT]));
  SetRCValue(28,1,'tau(s):');
  SetRCValue(29,5,'(Re):');
  SetRCValue(29,6,'(Im):');
  SetRCValue(30,1,'Tsett(s):');
  SetRCValue(30,4,'Bessel:');
  SetRCValue(30,5,'-4.0530');
  SetRCValue(31,5,'-4.0530');
  SetRCValue(31,4,'poles:');
  SetRCValue(30,6,'2.3400');
  SetRCValue(31,6,'-2.3400');
  SetRCValue(32,1,'PDctrl');
  SetRCValue(32,2,'(v):');
  SetRCValue(32,3,'(vn):');
  SetRCValue(32,4,'(w):');
  SetRCValue(32,5,'s^2 + a1');
  SetRCValue(32,6,'*s + a0');
  SetRCValue(33,1,'kc:');
  SetRCValue(34,1,'td:');
  SetRCValue(33,5,'a0:');
  SetRCValue(34,5,'a1:');
  BesselPrototypePDctrl(RangeToMatrix(27,2,2,3),GetRCValue(30,2),RangeToMatrix(30,5,2,2));

  // Interaction with the user
  SetRCValue(1,3,'[RESET]');
  SetRCValue(1,8,'[DEBUG]');
  SetRCValue(2,8 ,'[LogOnOff]');
  SetRCValue(2,10,'[LogSave]');
  SetRCValue(4,8 ,'[ChOnOff]');
  SetRCValue(4,10,'[ChType]');
  SetRCValue(4,12,'[ChClear]');
end;
